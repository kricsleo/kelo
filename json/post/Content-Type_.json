{"title":"Content-Type","date":"2018-10-12T02:32:51.000Z","updated":"2020-11-19T04:21:11.153Z","comments":true,"layout":"post","content":"<h1 id=\"Content-Type\"><a href=\"#Content-Type\" class=\"headerlink\" title=\"Content-Type\"></a>Content-Type</h1><p><code>HTTP/1.1</code>协议规定的<code>HTTP</code>请求方法有<code>OPTIONS</code>、<code>GET</code>、<code>HEAD</code>、<code>POST</code>、<code>PUT</code>、<code>DELETE</code>、<code>TRACE</code>、<code>CONNECT</code>这几种, 用的最多的是<code>GET</code>和<code>POST</code>, 这里主要说一下提交请求时的请求头中<code>Content-Type</code>字段</p>\n<a id=\"more\"></a>\n\n<h2 id=\"http请求结构\"><a href=\"#http请求结构\" class=\"headerlink\" title=\"http请求结构\"></a><code>http</code>请求结构</h2><p><code>http</code>请求分为三个部分: 状态行, 请求头和消息主体, 结构如下:</p>\n<pre><code class=\"hljs text\">&lt;method&gt; &lt;request url&gt; &lt;version&gt;\n&lt;headers&gt;\n\n&lt;entity-body&gt;</code></pre>\n\n<h2 id=\"Content-Type类型\"><a href=\"#Content-Type类型\" class=\"headerlink\" title=\"Content-Type类型\"></a>Content-Type类型</h2><p><code>Content-Type</code>有如下常见的类型:</p>\n<ul>\n<li><code>text/plain</code>: 文本类型</li>\n<li><code>text/html</code>: html文件类型</li>\n<li><code>text/css</code>: css文件类型</li>\n<li><code>text/javascript</code>: javascript文件类型</li>\n<li><code>application/x-www-form-urlencoded</code> POST讨论</li>\n<li><code>multipart/form-data</code> POST讨论</li>\n<li><code>application/json</code> POST讨论</li>\n<li><code>text/xml</code> POST中讨论</li>\n</ul>\n<p>由于<code>GET</code>方式的数据实际上是以<code>QueryString</code>的方式放在<code>&lt;request url&gt;</code>中的(非ASCII字符会被转码), 例如’<a href=\"https://www.example.com/?key1=value1&amp;key2=value2\">https://www.example.com?key1=value1&amp;key2=value2</a>‘, 所以对<code>GET</code>讨论<code>Content-Type</code>没有意义</p>\n<p><code>http</code>协议规定<code>POST</code>提交的数据必须放在消息主体（entity-body）中，但协议并没有规定数据必须使用什么编码方式。实际上，开发者完全可以自己决定消息主体的格式，只要最后发送的<code>HTTP</code>请求满足上面的格式就可以。</p>\n<p>服务端通常是根据请求头（headers）中的<code>Content-Type</code>字段来获知请求中的消息主体是用何种方式编码，再对主体进行解析。所以有必要了解<code>Content-Type</code>的内容. 目前在<code>POST</code>请求中所使用的<code>Content-Type</code>主要有如下四种类型: <code>application/x-www-urlencoded</code>, <code>multipart/form-data</code>, <code>application/json</code>, <code>text/xml</code>, 下面详细说一下这四种类型.</p>\n<h3 id=\"application-x-www-urlencoded\"><a href=\"#application-x-www-urlencoded\" class=\"headerlink\" title=\"application/x-www-urlencoded\"></a><code>application/x-www-urlencoded</code></h3><p>这应该是最常见的<code>POST</code>提交数据的方式了。浏览器的原生<code>&lt;form&gt;</code>表单，如果不设置<code>enctype</code>属性，那么默认就会以这种方式提交数据。这种方式会将表单中的数据按照<code>key1=value1&amp;key2=value2</code>的形式连接成字符串, 同时会将出现的非<code>ASCII</code>字符进行编码, 编码方式可以参考<code>encodeURIComponent()</code>函数, 例如下面这个表单提交时的数据结构:</p>\n<pre><code class=\"hljs text\">POST http://www.example.com HTTP/1.1\nContent-Type: application/x-www-form-urlencoded;charset=utf-8\n\ntitle=test&amp;sub%5B%5D=1&amp;sub%5B%5D=2&amp;sub%5B%5D=3</code></pre>\n\n<p>但是需要注意的是这是在<code>&lt;form&gt;</code>表单中没有<code>type=file</code>形内容的时候的提交方式, 如果表单中有二进制内容需要提交, 比如文件或者图片等, 那么就无法使用<code>application/x-www-urlencoded</code>方式, 需要转而使用下面会谈到的<code>multipart/form-data</code>方式.</p>\n<h3 id=\"multipart-form-data\"><a href=\"#multipart-form-data\" class=\"headerlink\" title=\"multipart/form-data\"></a><code>multipart/form-data</code></h3><p>当需要提交二进制数据如文件或者图片时就需要使用这种<code>multipart/form-data</code>, 一个常见的提交内容结构如下: </p>\n<pre><code class=\"hljs text\">POST http://www.example.com HTTP/1.1\nContent-Type:multipart/form-data; boundary=----WebKitFormBoundaryrGKCBY7qhFd3TrwA\n\n------WebKitFormBoundaryrGKCBY7qhFd3TrwA\nContent-Disposition: form-data; name=&quot;text&quot;\n\ntitle\n------WebKitFormBoundaryrGKCBY7qhFd3TrwA\nContent-Disposition: form-data; name=&quot;file&quot;; filename=&quot;chrome.png&quot;\nContent-Type: image/png\n\nPNG ... content of chrome.png ...\n------WebKitFormBoundaryrGKCBY7qhFd3TrwA--</code></pre>\n\n<p>请求头中的<code>boundary</code>代表将使用后面这一长串的字符串来分隔不同的字段, 消息主体里按照字段个数又分为多个结构类似的部分，每部分都是以<code>--boundary</code>开始，紧接着是内容描述信息，然后是回车，最后是字段具体内容（文本或二进制）。如果传输的是文件，还要包含文件名和文件类型信息。消息主体最后以<code>--boundary--</code>标示结束, 关于<code>multipart/form-data</code>的详细定义，请前往<a href=\"http://www.ietf.org/rfc/rfc1867.txt\">rfc1867</a>查看。</p>\n<p><code>application/x-www-urlencoded</code>和<code>multipart/form-data</code>都是浏览器原生支持的，而且现阶段标准中原生<code>&lt;form&gt;</code>表单也只支持这两种方式（通过<code>&lt;form&gt;</code>元素的<code>enctype</code>属性指定，默认为 application/x-www-form-urlencoded。其实<code>enctype</code>还支持<code>text/plain</code>，不过用得非常少）。</p>\n<p>下面提到的<code>Content-Type</code>属于随着技术的发展, 我们自定义出来的新的数据提交方式, 更为便捷.</p>\n<h3 id=\"application-json\"><a href=\"#application-json\" class=\"headerlink\" title=\"application/json\"></a><code>application/json</code></h3><p>因为<code>json</code>格式数据的读写性非常好, 用的也极为广泛, 所以<code>application/json</code>这个请求头也用的越来越多, 这个请求头就是告诉服务器发送的数据是序列化后的<code>json</code>字符串, 现在在做的<code>Vue</code>项目中用到的<code>Axios</code>所使用的默认就是<code>application/json</code>, 这里有一个问题就是Axios全局设置<code>Content-Type</code>为<code>application/x-www-urlencoded</code>不生效, 需要在请求发出前拦截方法中修改配置才能生效, 不知道是不是bug, 如下:</p>\n<pre><code class=\"hljs JavaScript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">_interceptorRequest</span>(<span class=\"hljs-params\">config</span>) </span>&#123;\n  config.headers[<span class=\"hljs-string\">&#x27;Content-Type&#x27;</span>] = <span class=\"hljs-string\">&#x27;application/x-www-form-urlencoded; charset=utf-8&#x27;</span>;\n  <span class=\"hljs-keyword\">return</span> config\n&#125;</code></pre>\n\n<p>使用<code>application/json</code>方式发送的数据结构类似下面这个: </p>\n<pre><code class=\"hljs text\">POST http://www.example.com HTTP/1.1 \nContent-Type: application/json;charset=utf-8\n\n&#123;&quot;title&quot;:&quot;test&quot;,&quot;sub&quot;:[1,2,3]&#125;</code></pre>\n\n<p><code>json</code>格式可以提交结构复杂的数据,在抓包工具或者调试中查看起来也很方便, 尤其适合<code>RESEful</code>的接口, 需要注意的是不论我们使用<code>application/x-www-urlencoded</code>还是<code>application/json</code>都要注意和服务器相配合, 因为毕竟我们发送的数据是希望服务器来正确接收和处理的, 如果客户端设置的<code>Content-Type</code>与服务端期望接收的<code>Content-Type</code>不一致就很有可能导致服务器无妨正常处理这个请求.</p>\n<h3 id=\"text-xml\"><a href=\"#text-xml\" class=\"headerlink\" title=\"text/xml\"></a>text/xml</h3><p>这是一种使用<code>HTTP</code>作为传输协议，<code>XML</code>作为编码方式的远程调用规范, 典型的<code>XML-RPC</code>请求如下: </p>\n<pre><code class=\"hljs text\">POST http://www.example.com HTTP/1.1\nContent-Type: text/xml\n\n&lt;?xml version=&quot;1.0&quot;?&gt;\n&lt;methodCall&gt;\n    &lt;methodName&gt;examples.getStateName&lt;/methodName&gt;\n    &lt;params&gt;\n        &lt;param&gt;\n            &lt;value&gt;&lt;i4&gt;41&lt;/i4&gt;&lt;/value&gt;\n        &lt;/param&gt;\n    &lt;/params&gt;\n&lt;/methodCall&gt;</code></pre>\n\n<p><code>XML-RPC</code>协议简单、功能够用，各种语言的实现都有。它的使用也很广泛，如<code>WordPress</code>的<code>XML-RPC</code>Api，搜索引擎的<code>ping</code>服务等等。<code>JavaScript</code>中，也有现成的库支持以这种方式进行数据交互，能很好的支持已有的 <code>XML-RPC</code>服务。</p>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><ul>\n<li><a href=\"https://imququ.com/post/four-ways-to-post-data-in-http.html\">四种常见的POST提交数据方式</a></li>\n<li><a href=\"https://www.chenshaowen.com/blog/content-type-http-header.html\">HTTP Header之Content-Type</a></li>\n</ul>\n","excerpt":"<h1 id=\"Content-Type\"><a href=\"#Content-Type\" class=\"headerlink\" title=\"Content-Type\"></a>Content-Type</h1><p><code>HTTP/1.1</code>协议规定的<code>HTTP</code>请求方法有<code>OPTIONS</code>、<code>GET</code>、<code>HEAD</code>、<code>POST</code>、<code>PUT</code>、<code>DELETE</code>、<code>TRACE</code>、<code>CONNECT</code>这几种, 用的最多的是<code>GET</code>和<code>POST</code>, 这里主要说一下提交请求时的请求头中<code>Content-Type</code>字段</p>","more":"<h2 id=\"http请求结构\"><a href=\"#http请求结构\" class=\"headerlink\" title=\"http请求结构\"></a><code>http</code>请求结构</h2><p><code>http</code>请求分为三个部分: 状态行, 请求头和消息主体, 结构如下:</p>\n<pre><code class=\"hljs text\">&lt;method&gt; &lt;request url&gt; &lt;version&gt;\n&lt;headers&gt;\n\n&lt;entity-body&gt;</code></pre>\n\n<h2 id=\"Content-Type类型\"><a href=\"#Content-Type类型\" class=\"headerlink\" title=\"Content-Type类型\"></a>Content-Type类型</h2><p><code>Content-Type</code>有如下常见的类型:</p>\n<ul>\n<li><code>text/plain</code>: 文本类型</li>\n<li><code>text/html</code>: html文件类型</li>\n<li><code>text/css</code>: css文件类型</li>\n<li><code>text/javascript</code>: javascript文件类型</li>\n<li><code>application/x-www-form-urlencoded</code> POST讨论</li>\n<li><code>multipart/form-data</code> POST讨论</li>\n<li><code>application/json</code> POST讨论</li>\n<li><code>text/xml</code> POST中讨论</li>\n</ul>\n<p>由于<code>GET</code>方式的数据实际上是以<code>QueryString</code>的方式放在<code>&lt;request url&gt;</code>中的(非ASCII字符会被转码), 例如’<a href=\"https://www.example.com/?key1=value1&amp;key2=value2\">https://www.example.com?key1=value1&amp;key2=value2</a>‘, 所以对<code>GET</code>讨论<code>Content-Type</code>没有意义</p>\n<p><code>http</code>协议规定<code>POST</code>提交的数据必须放在消息主体（entity-body）中，但协议并没有规定数据必须使用什么编码方式。实际上，开发者完全可以自己决定消息主体的格式，只要最后发送的<code>HTTP</code>请求满足上面的格式就可以。</p>\n<p>服务端通常是根据请求头（headers）中的<code>Content-Type</code>字段来获知请求中的消息主体是用何种方式编码，再对主体进行解析。所以有必要了解<code>Content-Type</code>的内容. 目前在<code>POST</code>请求中所使用的<code>Content-Type</code>主要有如下四种类型: <code>application/x-www-urlencoded</code>, <code>multipart/form-data</code>, <code>application/json</code>, <code>text/xml</code>, 下面详细说一下这四种类型.</p>\n<h3 id=\"application-x-www-urlencoded\"><a href=\"#application-x-www-urlencoded\" class=\"headerlink\" title=\"application/x-www-urlencoded\"></a><code>application/x-www-urlencoded</code></h3><p>这应该是最常见的<code>POST</code>提交数据的方式了。浏览器的原生<code>&lt;form&gt;</code>表单，如果不设置<code>enctype</code>属性，那么默认就会以这种方式提交数据。这种方式会将表单中的数据按照<code>key1=value1&amp;key2=value2</code>的形式连接成字符串, 同时会将出现的非<code>ASCII</code>字符进行编码, 编码方式可以参考<code>encodeURIComponent()</code>函数, 例如下面这个表单提交时的数据结构:</p>\n<pre><code class=\"hljs text\">POST http://www.example.com HTTP/1.1\nContent-Type: application/x-www-form-urlencoded;charset=utf-8\n\ntitle=test&amp;sub%5B%5D=1&amp;sub%5B%5D=2&amp;sub%5B%5D=3</code></pre>\n\n<p>但是需要注意的是这是在<code>&lt;form&gt;</code>表单中没有<code>type=file</code>形内容的时候的提交方式, 如果表单中有二进制内容需要提交, 比如文件或者图片等, 那么就无法使用<code>application/x-www-urlencoded</code>方式, 需要转而使用下面会谈到的<code>multipart/form-data</code>方式.</p>\n<h3 id=\"multipart-form-data\"><a href=\"#multipart-form-data\" class=\"headerlink\" title=\"multipart/form-data\"></a><code>multipart/form-data</code></h3><p>当需要提交二进制数据如文件或者图片时就需要使用这种<code>multipart/form-data</code>, 一个常见的提交内容结构如下: </p>\n<pre><code class=\"hljs text\">POST http://www.example.com HTTP/1.1\nContent-Type:multipart/form-data; boundary=----WebKitFormBoundaryrGKCBY7qhFd3TrwA\n\n------WebKitFormBoundaryrGKCBY7qhFd3TrwA\nContent-Disposition: form-data; name=&quot;text&quot;\n\ntitle\n------WebKitFormBoundaryrGKCBY7qhFd3TrwA\nContent-Disposition: form-data; name=&quot;file&quot;; filename=&quot;chrome.png&quot;\nContent-Type: image/png\n\nPNG ... content of chrome.png ...\n------WebKitFormBoundaryrGKCBY7qhFd3TrwA--</code></pre>\n\n<p>请求头中的<code>boundary</code>代表将使用后面这一长串的字符串来分隔不同的字段, 消息主体里按照字段个数又分为多个结构类似的部分，每部分都是以<code>--boundary</code>开始，紧接着是内容描述信息，然后是回车，最后是字段具体内容（文本或二进制）。如果传输的是文件，还要包含文件名和文件类型信息。消息主体最后以<code>--boundary--</code>标示结束, 关于<code>multipart/form-data</code>的详细定义，请前往<a href=\"http://www.ietf.org/rfc/rfc1867.txt\">rfc1867</a>查看。</p>\n<p><code>application/x-www-urlencoded</code>和<code>multipart/form-data</code>都是浏览器原生支持的，而且现阶段标准中原生<code>&lt;form&gt;</code>表单也只支持这两种方式（通过<code>&lt;form&gt;</code>元素的<code>enctype</code>属性指定，默认为 application/x-www-form-urlencoded。其实<code>enctype</code>还支持<code>text/plain</code>，不过用得非常少）。</p>\n<p>下面提到的<code>Content-Type</code>属于随着技术的发展, 我们自定义出来的新的数据提交方式, 更为便捷.</p>\n<h3 id=\"application-json\"><a href=\"#application-json\" class=\"headerlink\" title=\"application/json\"></a><code>application/json</code></h3><p>因为<code>json</code>格式数据的读写性非常好, 用的也极为广泛, 所以<code>application/json</code>这个请求头也用的越来越多, 这个请求头就是告诉服务器发送的数据是序列化后的<code>json</code>字符串, 现在在做的<code>Vue</code>项目中用到的<code>Axios</code>所使用的默认就是<code>application/json</code>, 这里有一个问题就是Axios全局设置<code>Content-Type</code>为<code>application/x-www-urlencoded</code>不生效, 需要在请求发出前拦截方法中修改配置才能生效, 不知道是不是bug, 如下:</p>\n<pre><code class=\"hljs JavaScript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">_interceptorRequest</span>(<span class=\"hljs-params\">config</span>) </span>&#123;\n  config.headers[<span class=\"hljs-string\">&#x27;Content-Type&#x27;</span>] = <span class=\"hljs-string\">&#x27;application/x-www-form-urlencoded; charset=utf-8&#x27;</span>;\n  <span class=\"hljs-keyword\">return</span> config\n&#125;</code></pre>\n\n<p>使用<code>application/json</code>方式发送的数据结构类似下面这个: </p>\n<pre><code class=\"hljs text\">POST http://www.example.com HTTP/1.1 \nContent-Type: application/json;charset=utf-8\n\n&#123;&quot;title&quot;:&quot;test&quot;,&quot;sub&quot;:[1,2,3]&#125;</code></pre>\n\n<p><code>json</code>格式可以提交结构复杂的数据,在抓包工具或者调试中查看起来也很方便, 尤其适合<code>RESEful</code>的接口, 需要注意的是不论我们使用<code>application/x-www-urlencoded</code>还是<code>application/json</code>都要注意和服务器相配合, 因为毕竟我们发送的数据是希望服务器来正确接收和处理的, 如果客户端设置的<code>Content-Type</code>与服务端期望接收的<code>Content-Type</code>不一致就很有可能导致服务器无妨正常处理这个请求.</p>\n<h3 id=\"text-xml\"><a href=\"#text-xml\" class=\"headerlink\" title=\"text/xml\"></a>text/xml</h3><p>这是一种使用<code>HTTP</code>作为传输协议，<code>XML</code>作为编码方式的远程调用规范, 典型的<code>XML-RPC</code>请求如下: </p>\n<pre><code class=\"hljs text\">POST http://www.example.com HTTP/1.1\nContent-Type: text/xml\n\n&lt;?xml version=&quot;1.0&quot;?&gt;\n&lt;methodCall&gt;\n    &lt;methodName&gt;examples.getStateName&lt;/methodName&gt;\n    &lt;params&gt;\n        &lt;param&gt;\n            &lt;value&gt;&lt;i4&gt;41&lt;/i4&gt;&lt;/value&gt;\n        &lt;/param&gt;\n    &lt;/params&gt;\n&lt;/methodCall&gt;</code></pre>\n\n<p><code>XML-RPC</code>协议简单、功能够用，各种语言的实现都有。它的使用也很广泛，如<code>WordPress</code>的<code>XML-RPC</code>Api，搜索引擎的<code>ping</code>服务等等。<code>JavaScript</code>中，也有现成的库支持以这种方式进行数据交互，能很好的支持已有的 <code>XML-RPC</code>服务。</p>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><ul>\n<li><a href=\"https://imququ.com/post/four-ways-to-post-data-in-http.html\">四种常见的POST提交数据方式</a></li>\n<li><a href=\"https://www.chenshaowen.com/blog/content-type-http-header.html\">HTTP Header之Content-Type</a></li>\n</ul>","source":"_posts/Content-Type.md","full_source":"/Users/krics/workspace/kricsleo_site/source/_posts/Content-Type.md","path":"Content-Type/","permalink":"https://kricsleo.com/Content-Type/","photos":[],"link":""}