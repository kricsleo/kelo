{"title":"Docker","date":"2018-09-10T05:19:34.000Z","updated":"2020-11-19T04:21:11.192Z","comments":true,"layout":"post","content":"<h1 id=\"docker学习笔记\"><a href=\"#docker学习笔记\" class=\"headerlink\" title=\"docker学习笔记\"></a>docker学习笔记</h1><p>Docker是一个开源的引擎，可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器。开发者在笔记本上编译测试通过的容器可以批量地在生产环境中部署，包括VMs（虚拟机）、bare metal、OpenStack 集群和其他的基础应用平台.</p>\n<a id=\"more\"></a>\n\n<p>如无特殊说明, 以下操作环境均为<code>CentOS 7</code>, 内核版本位<code>3.10.0-693.2.2.el7.x86_64</code><br>(查看内核版本: <code>uname -r</code>)</p>\n<h2 id=\"docker常用命令\"><a href=\"#docker常用命令\" class=\"headerlink\" title=\"docker常用命令\"></a>docker常用命令</h2><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 安装docker</span>\nyum install -y docker\n\n<span class=\"hljs-comment\"># 查看已安装的docker, 或者 docker info</span>\ndocker version\n\n<span class=\"hljs-comment\"># 启动docker服务</span>\nservice docker start\n\n<span class=\"hljs-comment\"># 查看已下载的镜像 或 docker images</span>\ndocker image ls \n\n<span class=\"hljs-comment\"># 从仓库抓取镜像到本地, Docker 官方提供的镜像都存放在 library 组里, 同时这也是默认的组</span>\n<span class=\"hljs-comment\"># 例如 docker image pull library/hello-world 等价于 docker image pull hello-world</span>\ndocker image pull [imageName]\n\n<span class=\"hljs-comment\"># 删除已下载的镜像, 如果有使用该镜像创建的容器, 那么必须先删除对应的容器才能删除镜像</span>\ndocker image rm [imageName]\n\n<span class=\"hljs-comment\"># 从镜像创建容器并运行</span>\n<span class=\"hljs-comment\"># 给个hello-world的测试例子, 由于本地没有hello-world这个镜像，所以会自动下载一个hello-world的镜像，并在容器内运行。</span>\ndocker run [imageName]\n\n<span class=\"hljs-comment\"># 列出正在运行的容器</span>\n<span class=\"hljs-comment\"># dcoker container ls</span>\n<span class=\"hljs-comment\"># docker contaienr ls --all 列出所有容器, 包括已停止的</span>\ndocker ps\n\n<span class=\"hljs-comment\"># 停止容器 或强制停止: docker container kill [containID]</span>\ndocker stop [containerId]\n\n<span class=\"hljs-comment\"># 启动已经停止的容器</span>\ndocker start [containerId]\n\n<span class=\"hljs-comment\"># 重启容器</span>\ndocker restart [containerId]\n\n<span class=\"hljs-comment\"># 删除容器</span>\ndocker rm [containerId]\n\n<span class=\"hljs-comment\"># 获取容器的输出信息</span>\ndocker logs [containerId]\n\n<span class=\"hljs-comment\"># 查看当前已经运行的容器(可以看到容器id: CONTAINER_ID)</span>\ndocker ps\n\n<span class=\"hljs-comment\"># 进入容器内部(推荐使用exec)</span>\ndocker <span class=\"hljs-built_in\">exec</span> -it [containerId] /bin/bash\n<span class=\"hljs-comment\"># 参数说明</span>\n<span class=\"hljs-comment\"># -i 以交互方式运行，是阻塞式的</span>\n<span class=\"hljs-comment\"># -t 分配一个伪终端，这个参数通常与-i参数一起使用，然后， 在后面跟上容器里的/bin/bash，这样就把我们带到容器里去了。</span>\n<span class=\"hljs-comment\"># -d 以后台方式执行，这样，我们执行完这条命令，还可以干其他事情，写脚本最常用</span>\n\n<span class=\"hljs-comment\"># 查看某个容器的日志</span>\ndocker container logs [containerId]\n\n<span class=\"hljs-comment\"># 在宿主机和容器之间拷贝文件, 容器未启动也可拷贝</span>\n<span class=\"hljs-comment\"># docker cp containerId:from/path/to/file to/owner/path</span>\ndocker cp from/owner/path containerId:to/path/to/file\n\n<span class=\"hljs-comment\"># 查看各容器占用的系统资源</span>\ndocker stats\n\n<span class=\"hljs-comment\"># 保存对容器的更改, 生成一个新的镜像</span>\ndocker commit [containerId] [newImageName]</code></pre>\n\n<h2 id=\"编写一个-Dockerfile\"><a href=\"#编写一个-Dockerfile\" class=\"headerlink\" title=\"编写一个 Dockerfile\"></a>编写一个 Dockerfile</h2><p>我们可以从一个 Dockerfile 来新建一个镜像来满足自己自定义的需求.</p>\n<p>我们一般会新建一个<code>.dockerignore</code>文件, 表示在拷贝文件到镜像中的时候要忽略哪些文件, 就像是<code>.gitignore</code>一样(语法也一样), 一般而言, 我们都会忽略诸如<code>.git</code>和<code>node_modules/</code>等文件夹</p>\n<pre><code class=\"hljs dockerfile\"><span class=\"hljs-comment\"># FROM 表示新建的镜像文件所依赖的基础镜像, 我这里是在8.12.0的版本的node镜像的基础上进行定制的</span>\n<span class=\"hljs-keyword\">FROM</span> node:<span class=\"hljs-number\">8.12</span>.<span class=\"hljs-number\">0</span>\n<span class=\"hljs-comment\"># LABEL 指令用于向镜像中添加元数据，可以通过docker inspect命令查看, 比如下面指定该镜像维护者信息(旧的 MAINTAINER 字段已经废弃)</span>\n<span class=\"hljs-keyword\">LABEL</span><span class=\"bash\"> maintainer=<span class=\"hljs-string\">&quot;kricsleo.com&quot;</span></span>\n<span class=\"hljs-comment\"># COPY 表示文件拷贝, 第一个参数是本机源文件路径, 第二个参数是镜像中的目的文件路径, 这里表示将当前文件夹下的内容全部拷贝到镜像中的`/workspace/node`目录中</span>\n<span class=\"hljs-comment\"># 与 COPY 类似的命令是 ADD, ADD 的功能更丰富, 除了与 COPY 相同的作用外, 它还可以下载远程的文件拷贝进去, 还可以将压缩的文件自动解压后拷贝到镜像中</span>\n<span class=\"hljs-keyword\">COPY</span><span class=\"bash\"> . /workspace/node</span>\n<span class=\"hljs-comment\"># WORKDIR 指定镜像中接下来的工作目录, 命令等都将在这个目录上执行</span>\n<span class=\"hljs-keyword\">WORKDIR</span><span class=\"bash\"> /workspace/node</span>\n<span class=\"hljs-comment\"># RUN 表示新建镜像前要执行的命令, 这里执行了`npm install`将会安装项目的所有依赖, 这些依赖安装完成后都会被打包进入镜像文件中</span>\n<span class=\"hljs-comment\"># RUN 命令可以有多个, 每一个 RUN 命令都会创建一层镜像, 类似于洋葱结构, 后面的 RUN 失败导致镜像构建失败时, 下次重新构建的话会从上一个成功的</span>\n<span class=\"hljs-comment\"># 那一层镜像开始构建, 注意可以按照需求合并 RUN 命令, 可以避免多余的层级</span>\n<span class=\"hljs-keyword\">RUN</span><span class=\"bash\"> npm install</span>\n<span class=\"hljs-comment\"># EXPOSE 表示向外提供服务的端口号, 可以指定多个, 用空格分开即可, 一般我们可以在后面创建容器的时候使用`-p`参数来将宿主机和容器中暴露的端口号进行映射</span>\n<span class=\"hljs-keyword\">EXPOSE</span> <span class=\"hljs-number\">3000</span>\n<span class=\"hljs-comment\"># CMD 表示启动容器之后在容器中要运行的命令, 这里相当于告诉容器运行之后运行`/bin/bash`</span>\n<span class=\"hljs-comment\"># 我们一般在从镜像启动容器的时候类似于`docker run -it &lt;image&gt; /bin/bash`, 这里最后的`/bin/bash`命令会覆盖我们指定的 CMD 命令</span>\n<span class=\"hljs-comment\"># CMD 命令只能存在一个, CMD [command, param1, param2, ...], 后面的参数都会传递给这个命令</span>\n<span class=\"hljs-keyword\">CMD</span><span class=\"bash\"> [<span class=\"hljs-string\">&#x27;/bin/bash&#x27;</span>]</span></code></pre>\n\n<p>Dockerfile 编写完成以后我们就可以来使用它构建一个镜像了.</p>\n<pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># build 表示开始构建镜像</span>\n<span class=\"hljs-comment\"># -t 表示构建的镜像名和版本标签, 默认是 latest</span>\n<span class=\"hljs-comment\"># -f 指定 Dockerfile 的路径</span>\n<span class=\"hljs-comment\"># 最后的 . 表示工作环境为当前目录, 如果 Dockerfile 也在当前目录, 那么可以不用指定 -f 参数</span>\ndocker build -t [imageName:tag] -f [/path/to/Dockerfile] .</code></pre>\n\n<p>参考资料:<a href=\"http://notes.maxwi.com/2017/12/14/docker-Dockerfile/\">Dockerfile的编写</a></p>\n<h2 id=\"docker中使用mysql\"><a href=\"#docker中使用mysql\" class=\"headerlink\" title=\"docker中使用mysql\"></a>docker中使用mysql</h2><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 下载mysql镜像</span>\ndocker pull mysql\n\n<span class=\"hljs-comment\"># 从镜像创建并运行一个容器</span>\ndocker run --name first-mysql -p 3306:3306 -e MYSQL\\_ROOT\\_PASSWORD=root -d mysql\n<span class=\"hljs-comment\"># 参数说明:</span>\n<span class=\"hljs-comment\"># --name 指定容器独一无二的名字</span>\n<span class=\"hljs-comment\"># -p mysql容器的端口映射</span>\n<span class=\"hljs-comment\"># -e &lt;key=value&gt;\t设置进入后可以使用的环境变量，这样动态指定比较灵活,  &#x27;MYSQL\\_ROOT\\_PASSWORD&#x27;字段指定的是 root</span>\n<span class=\"hljs-comment\"># 用户的密码</span>\n<span class=\"hljs-comment\"># -d 表示使用守护进程, 即服务挂在后台</span></code></pre>\n\n<p>在我本机连接阿里云上的ECS中的mysql容器时无法连接, 后来排查使用如下解决方案:</p>\n<ol>\n<li><p>编辑ECS的安全组规则<br>把mysql的通信端口3306加入到允许列表中, 如果你是把docker里面的mysql的端口映射到ECS的其它端口, 比如3307, 那么这里你就把这个映射之后的端口3307加入到运行列表即可;</p>\n</li>\n<li><p>编辑ECS的防火墙<br>ECS的防火墙可能会拦截3306端口的通信, 那么你需要打开这个端口, 让防火墙允许端口通信, 我的ECS系统是CentOS7, 在CentOS7中是使用<code>firewall</code>来管理端口通信的, 那么使用如下方法加入3306端口: </p>\n<pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 永久加入3306端口</span>\nfirewall-cmd --zone=public --add-port=3306/tcp --permanent\n<span class=\"hljs-comment\"># 参数说明:</span>\n<span class=\"hljs-comment\"># –zone 作用域</span>\n<span class=\"hljs-comment\"># –add-port=80/tcp 添加端口，格式为：端口/通讯协议</span>\n<span class=\"hljs-comment\"># –permanent 永久生效，没有此参数重启后失效</span>\n\n<span class=\"hljs-comment\"># 重启防火墙生效</span>\nfirewall-cmd --reload</code></pre>\n\n<p>另外附上常用防火墙命令:</p>\n<pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 关闭防火墙</span>\nsystemctl stop firewalld\n\n<span class=\"hljs-comment\">#打开防火墙</span>\nsystemctl start firewalld\n\n<span class=\"hljs-comment\">#查看防火墙状态</span>\nfirewall-cmd --state</code></pre>\n\n</li>\n</ol>\n<h2 id=\"安装-Elasticsearch\"><a href=\"#安装-Elasticsearch\" class=\"headerlink\" title=\"安装 Elasticsearch\"></a>安装 Elasticsearch</h2><p>我安装的版本是<strong>6.5.4</strong>, 需要指定版本安装, 因为没有默认的’lastest’版本</p>\n<pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># -it 参数代表分配并且进入该容器的终端, 可以看到命令行详细的启动过程, 也可以进行命令交互</span>\n<span class=\"hljs-comment\"># -d 参数代表在后台守护该容器的进程一直运行</span>\n<span class=\"hljs-comment\"># --name: 为此次运行的容器起一个好记的名字</span>\n<span class=\"hljs-comment\"># 使用 -e 指定多个参数, 因为我服务器是个只有1G内存的小水管, 而 es 在5版本之后的默认最大内存使用是2G, 所以我</span>\n<span class=\"hljs-comment\"># 指定了 ES_JAVA_OPTS=&quot;-Xms200m -Xmx200m&quot; 参数来限制最大使用 200m 堆内存, 但是不知道怎么回事, 内存还是会一直往上飙,</span>\n<span class=\"hljs-comment\"># 会远远超过我指定的内存</span>\n<span class=\"hljs-comment\"># 指定 NETWORK_HOST=&quot;0.0.0.0&quot;, 可以让 es 接受来自任意ip地址的访问</span>\n<span class=\"hljs-comment\"># 最后指定了本次启动的容器从 docker.io/elasticsearch:6.5.4 镜像创建</span>\ndocker run -d --name es -p 9200:9200 -p 9300:9300 -e ES_JAVA_OPTS=<span class=\"hljs-string\">&quot;-Xms150m -Xmx150m&quot;</span> -e NETWORK_HOST=<span class=\"hljs-string\">&quot;0.0.0.0&quot;</span> docker.io/elasticsearch:6.5.4</code></pre>\n\n<h3 id=\"安装-elasticsearch-head\"><a href=\"#安装-elasticsearch-head\" class=\"headerlink\" title=\"安装 elasticsearch-head\"></a>安装 elasticsearch-head</h3><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># elasticsearch-head 使用的端口是9100</span>\ndocker run -d -p 9100:9100 docker.io/mobz/elasticsearch-head:5</code></pre>\n\n<p>然后访问ip:9100, 在页面上填入 es 的地址ip:9200, 如果无法连接, 那么需要在 es 的配置文件 <code>elasticsearch.yml</code>中添加参数</p>\n<pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 如果启用了 HTTP 端口，那么此属性会指定是否允许跨源 REST 请求</span>\nhttp.cors.enabled: <span class=\"hljs-literal\">true</span>\n<span class=\"hljs-comment\"># 如果 http.cors.enabled 的值为 true，那么该属性会指定允许 REST 请求来自何处</span>\nhttp.cors.allow-origin: <span class=\"hljs-string\">&quot;*&quot;</span></code></pre>\n\n<h3 id=\"安装中文分词-ik\"><a href=\"#安装中文分词-ik\" class=\"headerlink\" title=\"安装中文分词 ik\"></a>安装中文分词 ik</h3><p>进入 es 容器中, 使用 es 自带的命令安装插件</p>\n<pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 注意安装对应 es 版本的 ik 分词插件, 我的 es 是6.5.4, 所以安装的6.5.4的 ik</span>\nelasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v6.5.4/elasticsearch-analysis-ik-6.5.4.zip</code></pre>\n\n<h3 id=\"elasticsearch-的使用\"><a href=\"#elasticsearch-的使用\" class=\"headerlink\" title=\"elasticsearch 的使用\"></a>elasticsearch 的使用</h3><p>参考<a href=\"https://imququ.com/post/elasticsearch.html\">使用 Elasticsearch 实现博客站内搜索</a></p>\n<p>初始化和写入数据都可以了, 但是现在碰到一个问题, 我的博客主站是托管在 github 上的, github 只提供静态资源服务, 那么我这个部署在阿里云上的 es 要如何联动起来使用上搜索功能呢?</p>\n<p><del>通过 nginx 分发?</del>目前使用 nginx 分发达到了在备用域名 try.kricsleo.com 上可以调用部署在阿里云上的 es 服务</p>\n<p>放出我的博客文章的 mapping </p>\n<pre><code class=\"hljs js\">&#123;\n  index: <span class=\"hljs-string\">&#x27;blog&#x27;</span>,\n  type: <span class=\"hljs-string\">&#x27;article&#x27;</span>,\n  body: &#123;\n    properties: &#123;\n      title: &#123;\n        type: <span class=\"hljs-string\">&#x27;text&#x27;</span>,\n        term_vector: <span class=\"hljs-string\">&#x27;with_positions_offsets&#x27;</span>,\n        analyzer: <span class=\"hljs-string\">&#x27;ik_max_word&#x27;</span>,\n        search_analyzer: <span class=\"hljs-string\">&#x27;ik_max_word&#x27;</span>\n      &#125;,\n      subtitle: &#123;\n        type: <span class=\"hljs-string\">&#x27;text&#x27;</span>,\n        term_vector: <span class=\"hljs-string\">&#x27;with_positions_offsets&#x27;</span>,\n        analyzer: <span class=\"hljs-string\">&#x27;ik_max_word&#x27;</span>,\n        search_analyzer: <span class=\"hljs-string\">&#x27;ik_max_word&#x27;</span>\n      &#125;,\n      content: &#123;\n        type: <span class=\"hljs-string\">&#x27;text&#x27;</span>,\n        term_vector: <span class=\"hljs-string\">&#x27;with_positions_offsets&#x27;</span>,\n        analyzer: <span class=\"hljs-string\">&#x27;ik_max_word&#x27;</span>,\n        search_analyzer: <span class=\"hljs-string\">&#x27;ik_max_word&#x27;</span>\n      &#125;,\n      link: &#123;\n        type: <span class=\"hljs-string\">&#x27;text&#x27;</span>\n      &#125;,\n      author: &#123;\n        type: <span class=\"hljs-string\">&#x27;text&#x27;</span>,\n      &#125;,\n      categories: &#123;\n        type: <span class=\"hljs-string\">&#x27;keyword&#x27;</span>,\n      &#125;,\n      tags: &#123;\n        type: <span class=\"hljs-string\">&#x27;keyword&#x27;</span>,\n      &#125;,\n      create_date: &#123;\n        type: <span class=\"hljs-string\">&#x27;date&#x27;</span>,\n        index: <span class=\"hljs-literal\">false</span>\n      &#125;,\n      update_date: &#123;\n        type: <span class=\"hljs-string\">&#x27;date&#x27;</span>,\n        index: <span class=\"hljs-literal\">false</span>\n      &#125;\n    &#125;\n  &#125;\n&#125;</code></pre>\n\n<p>搜索时使用的生成 DSL 查询语句的方法</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> generateDSL = <span class=\"hljs-function\">(<span class=\"hljs-params\">query = <span class=\"hljs-string\">&#x27;&#x27;</span>, <span class=\"hljs-keyword\">from</span> = <span class=\"hljs-number\">0</span>, size = <span class=\"hljs-number\">10</span></span>) =&gt;</span> (&#123;\n  index: <span class=\"hljs-string\">&#x27;blog&#x27;</span>,\n  type: <span class=\"hljs-string\">&#x27;article&#x27;</span>,\n  q: query,\n  <span class=\"hljs-keyword\">from</span>,\n  size,\n  body: &#123;\n    query: &#123;\n      dis_max: &#123;\n        queries: [\n          &#123;\n            match: &#123;\n              title: &#123;\n                query: keyword,\n                minimum_should_match: <span class=\"hljs-string\">&#x27;50%&#x27;</span>,\n                boost: <span class=\"hljs-number\">4</span>,\n              &#125;\n            &#125;\n          &#125;,\n          &#123;\n            match: &#123;\n              subtitle: &#123;\n                query: keyword,\n                minimum_should_match: <span class=\"hljs-string\">&#x27;50%&#x27;</span>,\n                boost: <span class=\"hljs-number\">4</span>,\n              &#125;\n            &#125;\n          &#125;, &#123;\n            match: &#123;\n              content: &#123;\n                query: keyword,\n                minimum_should_match: <span class=\"hljs-string\">&#x27;75%&#x27;</span>,\n                boost: <span class=\"hljs-number\">4</span>,\n              &#125;\n            &#125;\n          &#125;, &#123;\n            match: &#123;\n              tags: &#123;\n                query: keyword,\n                minimum_should_match: <span class=\"hljs-string\">&#x27;100%&#x27;</span>,\n                boost: <span class=\"hljs-number\">2</span>,\n              &#125;\n            &#125;\n          &#125;, &#123;\n            match: &#123;\n              categories: &#123;\n                query: keyword,\n                minimum_should_match: <span class=\"hljs-string\">&#x27;100%&#x27;</span>,\n                boost: <span class=\"hljs-number\">2</span>,\n              &#125;\n            &#125;\n          &#125;\n        ],\n        tie_breaker: <span class=\"hljs-number\">0.3</span>\n      &#125;\n    &#125;,\n    highlight: &#123;\n      pre_tags: [<span class=\"hljs-string\">&#x27;&lt;b&gt;&#x27;</span>],\n      post_tags: [<span class=\"hljs-string\">&#x27;&lt;/b&gt;&#x27;</span>],\n      fields: &#123;\n        title: &#123;&#125;,\n        content: &#123;&#125;,\n      &#125;\n    &#125;\n  &#125;\n&#125;);</code></pre>\n\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"https://imququ.com/post/elasticsearch.html\">使用 Elasticsearch 实现博客站内搜索</a><br><a href=\"http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html\">Docker 入门教程</a><br><a href=\"https://www.xuchuruo.cn/%E4%BD%BF%E7%94%A8docker%E5%AE%89%E8%A3%85elasticsearch.html\">docker安装elasticSearch以及系列插件</a><br><a href=\"https://blog.csdn.net/qq_23250633/article/details/81327001\">Docker安装elasticsearch5（爬坑心得）</a>: 内存不足无法启动 es 解决方法</p>\n","excerpt":"<h1 id=\"docker学习笔记\"><a href=\"#docker学习笔记\" class=\"headerlink\" title=\"docker学习笔记\"></a>docker学习笔记</h1><p>Docker是一个开源的引擎，可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器。开发者在笔记本上编译测试通过的容器可以批量地在生产环境中部署，包括VMs（虚拟机）、bare metal、OpenStack 集群和其他的基础应用平台.</p>","more":"<p>如无特殊说明, 以下操作环境均为<code>CentOS 7</code>, 内核版本位<code>3.10.0-693.2.2.el7.x86_64</code><br>(查看内核版本: <code>uname -r</code>)</p>\n<h2 id=\"docker常用命令\"><a href=\"#docker常用命令\" class=\"headerlink\" title=\"docker常用命令\"></a>docker常用命令</h2><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 安装docker</span>\nyum install -y docker\n\n<span class=\"hljs-comment\"># 查看已安装的docker, 或者 docker info</span>\ndocker version\n\n<span class=\"hljs-comment\"># 启动docker服务</span>\nservice docker start\n\n<span class=\"hljs-comment\"># 查看已下载的镜像 或 docker images</span>\ndocker image ls \n\n<span class=\"hljs-comment\"># 从仓库抓取镜像到本地, Docker 官方提供的镜像都存放在 library 组里, 同时这也是默认的组</span>\n<span class=\"hljs-comment\"># 例如 docker image pull library/hello-world 等价于 docker image pull hello-world</span>\ndocker image pull [imageName]\n\n<span class=\"hljs-comment\"># 删除已下载的镜像, 如果有使用该镜像创建的容器, 那么必须先删除对应的容器才能删除镜像</span>\ndocker image rm [imageName]\n\n<span class=\"hljs-comment\"># 从镜像创建容器并运行</span>\n<span class=\"hljs-comment\"># 给个hello-world的测试例子, 由于本地没有hello-world这个镜像，所以会自动下载一个hello-world的镜像，并在容器内运行。</span>\ndocker run [imageName]\n\n<span class=\"hljs-comment\"># 列出正在运行的容器</span>\n<span class=\"hljs-comment\"># dcoker container ls</span>\n<span class=\"hljs-comment\"># docker contaienr ls --all 列出所有容器, 包括已停止的</span>\ndocker ps\n\n<span class=\"hljs-comment\"># 停止容器 或强制停止: docker container kill [containID]</span>\ndocker stop [containerId]\n\n<span class=\"hljs-comment\"># 启动已经停止的容器</span>\ndocker start [containerId]\n\n<span class=\"hljs-comment\"># 重启容器</span>\ndocker restart [containerId]\n\n<span class=\"hljs-comment\"># 删除容器</span>\ndocker rm [containerId]\n\n<span class=\"hljs-comment\"># 获取容器的输出信息</span>\ndocker logs [containerId]\n\n<span class=\"hljs-comment\"># 查看当前已经运行的容器(可以看到容器id: CONTAINER_ID)</span>\ndocker ps\n\n<span class=\"hljs-comment\"># 进入容器内部(推荐使用exec)</span>\ndocker <span class=\"hljs-built_in\">exec</span> -it [containerId] /bin/bash\n<span class=\"hljs-comment\"># 参数说明</span>\n<span class=\"hljs-comment\"># -i 以交互方式运行，是阻塞式的</span>\n<span class=\"hljs-comment\"># -t 分配一个伪终端，这个参数通常与-i参数一起使用，然后， 在后面跟上容器里的/bin/bash，这样就把我们带到容器里去了。</span>\n<span class=\"hljs-comment\"># -d 以后台方式执行，这样，我们执行完这条命令，还可以干其他事情，写脚本最常用</span>\n\n<span class=\"hljs-comment\"># 查看某个容器的日志</span>\ndocker container logs [containerId]\n\n<span class=\"hljs-comment\"># 在宿主机和容器之间拷贝文件, 容器未启动也可拷贝</span>\n<span class=\"hljs-comment\"># docker cp containerId:from/path/to/file to/owner/path</span>\ndocker cp from/owner/path containerId:to/path/to/file\n\n<span class=\"hljs-comment\"># 查看各容器占用的系统资源</span>\ndocker stats\n\n<span class=\"hljs-comment\"># 保存对容器的更改, 生成一个新的镜像</span>\ndocker commit [containerId] [newImageName]</code></pre>\n\n<h2 id=\"编写一个-Dockerfile\"><a href=\"#编写一个-Dockerfile\" class=\"headerlink\" title=\"编写一个 Dockerfile\"></a>编写一个 Dockerfile</h2><p>我们可以从一个 Dockerfile 来新建一个镜像来满足自己自定义的需求.</p>\n<p>我们一般会新建一个<code>.dockerignore</code>文件, 表示在拷贝文件到镜像中的时候要忽略哪些文件, 就像是<code>.gitignore</code>一样(语法也一样), 一般而言, 我们都会忽略诸如<code>.git</code>和<code>node_modules/</code>等文件夹</p>\n<pre><code class=\"hljs dockerfile\"><span class=\"hljs-comment\"># FROM 表示新建的镜像文件所依赖的基础镜像, 我这里是在8.12.0的版本的node镜像的基础上进行定制的</span>\n<span class=\"hljs-keyword\">FROM</span> node:<span class=\"hljs-number\">8.12</span>.<span class=\"hljs-number\">0</span>\n<span class=\"hljs-comment\"># LABEL 指令用于向镜像中添加元数据，可以通过docker inspect命令查看, 比如下面指定该镜像维护者信息(旧的 MAINTAINER 字段已经废弃)</span>\n<span class=\"hljs-keyword\">LABEL</span><span class=\"bash\"> maintainer=<span class=\"hljs-string\">&quot;kricsleo.com&quot;</span></span>\n<span class=\"hljs-comment\"># COPY 表示文件拷贝, 第一个参数是本机源文件路径, 第二个参数是镜像中的目的文件路径, 这里表示将当前文件夹下的内容全部拷贝到镜像中的`/workspace/node`目录中</span>\n<span class=\"hljs-comment\"># 与 COPY 类似的命令是 ADD, ADD 的功能更丰富, 除了与 COPY 相同的作用外, 它还可以下载远程的文件拷贝进去, 还可以将压缩的文件自动解压后拷贝到镜像中</span>\n<span class=\"hljs-keyword\">COPY</span><span class=\"bash\"> . /workspace/node</span>\n<span class=\"hljs-comment\"># WORKDIR 指定镜像中接下来的工作目录, 命令等都将在这个目录上执行</span>\n<span class=\"hljs-keyword\">WORKDIR</span><span class=\"bash\"> /workspace/node</span>\n<span class=\"hljs-comment\"># RUN 表示新建镜像前要执行的命令, 这里执行了`npm install`将会安装项目的所有依赖, 这些依赖安装完成后都会被打包进入镜像文件中</span>\n<span class=\"hljs-comment\"># RUN 命令可以有多个, 每一个 RUN 命令都会创建一层镜像, 类似于洋葱结构, 后面的 RUN 失败导致镜像构建失败时, 下次重新构建的话会从上一个成功的</span>\n<span class=\"hljs-comment\"># 那一层镜像开始构建, 注意可以按照需求合并 RUN 命令, 可以避免多余的层级</span>\n<span class=\"hljs-keyword\">RUN</span><span class=\"bash\"> npm install</span>\n<span class=\"hljs-comment\"># EXPOSE 表示向外提供服务的端口号, 可以指定多个, 用空格分开即可, 一般我们可以在后面创建容器的时候使用`-p`参数来将宿主机和容器中暴露的端口号进行映射</span>\n<span class=\"hljs-keyword\">EXPOSE</span> <span class=\"hljs-number\">3000</span>\n<span class=\"hljs-comment\"># CMD 表示启动容器之后在容器中要运行的命令, 这里相当于告诉容器运行之后运行`/bin/bash`</span>\n<span class=\"hljs-comment\"># 我们一般在从镜像启动容器的时候类似于`docker run -it &lt;image&gt; /bin/bash`, 这里最后的`/bin/bash`命令会覆盖我们指定的 CMD 命令</span>\n<span class=\"hljs-comment\"># CMD 命令只能存在一个, CMD [command, param1, param2, ...], 后面的参数都会传递给这个命令</span>\n<span class=\"hljs-keyword\">CMD</span><span class=\"bash\"> [<span class=\"hljs-string\">&#x27;/bin/bash&#x27;</span>]</span></code></pre>\n\n<p>Dockerfile 编写完成以后我们就可以来使用它构建一个镜像了.</p>\n<pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># build 表示开始构建镜像</span>\n<span class=\"hljs-comment\"># -t 表示构建的镜像名和版本标签, 默认是 latest</span>\n<span class=\"hljs-comment\"># -f 指定 Dockerfile 的路径</span>\n<span class=\"hljs-comment\"># 最后的 . 表示工作环境为当前目录, 如果 Dockerfile 也在当前目录, 那么可以不用指定 -f 参数</span>\ndocker build -t [imageName:tag] -f [/path/to/Dockerfile] .</code></pre>\n\n<p>参考资料:<a href=\"http://notes.maxwi.com/2017/12/14/docker-Dockerfile/\">Dockerfile的编写</a></p>\n<h2 id=\"docker中使用mysql\"><a href=\"#docker中使用mysql\" class=\"headerlink\" title=\"docker中使用mysql\"></a>docker中使用mysql</h2><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 下载mysql镜像</span>\ndocker pull mysql\n\n<span class=\"hljs-comment\"># 从镜像创建并运行一个容器</span>\ndocker run --name first-mysql -p 3306:3306 -e MYSQL\\_ROOT\\_PASSWORD=root -d mysql\n<span class=\"hljs-comment\"># 参数说明:</span>\n<span class=\"hljs-comment\"># --name 指定容器独一无二的名字</span>\n<span class=\"hljs-comment\"># -p mysql容器的端口映射</span>\n<span class=\"hljs-comment\"># -e &lt;key=value&gt;\t设置进入后可以使用的环境变量，这样动态指定比较灵活,  &#x27;MYSQL\\_ROOT\\_PASSWORD&#x27;字段指定的是 root</span>\n<span class=\"hljs-comment\"># 用户的密码</span>\n<span class=\"hljs-comment\"># -d 表示使用守护进程, 即服务挂在后台</span></code></pre>\n\n<p>在我本机连接阿里云上的ECS中的mysql容器时无法连接, 后来排查使用如下解决方案:</p>\n<ol>\n<li><p>编辑ECS的安全组规则<br>把mysql的通信端口3306加入到允许列表中, 如果你是把docker里面的mysql的端口映射到ECS的其它端口, 比如3307, 那么这里你就把这个映射之后的端口3307加入到运行列表即可;</p>\n</li>\n<li><p>编辑ECS的防火墙<br>ECS的防火墙可能会拦截3306端口的通信, 那么你需要打开这个端口, 让防火墙允许端口通信, 我的ECS系统是CentOS7, 在CentOS7中是使用<code>firewall</code>来管理端口通信的, 那么使用如下方法加入3306端口: </p>\n<pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 永久加入3306端口</span>\nfirewall-cmd --zone=public --add-port=3306/tcp --permanent\n<span class=\"hljs-comment\"># 参数说明:</span>\n<span class=\"hljs-comment\"># –zone 作用域</span>\n<span class=\"hljs-comment\"># –add-port=80/tcp 添加端口，格式为：端口/通讯协议</span>\n<span class=\"hljs-comment\"># –permanent 永久生效，没有此参数重启后失效</span>\n\n<span class=\"hljs-comment\"># 重启防火墙生效</span>\nfirewall-cmd --reload</code></pre>\n\n<p>另外附上常用防火墙命令:</p>\n<pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 关闭防火墙</span>\nsystemctl stop firewalld\n\n<span class=\"hljs-comment\">#打开防火墙</span>\nsystemctl start firewalld\n\n<span class=\"hljs-comment\">#查看防火墙状态</span>\nfirewall-cmd --state</code></pre>\n\n</li>\n</ol>\n<h2 id=\"安装-Elasticsearch\"><a href=\"#安装-Elasticsearch\" class=\"headerlink\" title=\"安装 Elasticsearch\"></a>安装 Elasticsearch</h2><p>我安装的版本是<strong>6.5.4</strong>, 需要指定版本安装, 因为没有默认的’lastest’版本</p>\n<pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># -it 参数代表分配并且进入该容器的终端, 可以看到命令行详细的启动过程, 也可以进行命令交互</span>\n<span class=\"hljs-comment\"># -d 参数代表在后台守护该容器的进程一直运行</span>\n<span class=\"hljs-comment\"># --name: 为此次运行的容器起一个好记的名字</span>\n<span class=\"hljs-comment\"># 使用 -e 指定多个参数, 因为我服务器是个只有1G内存的小水管, 而 es 在5版本之后的默认最大内存使用是2G, 所以我</span>\n<span class=\"hljs-comment\"># 指定了 ES_JAVA_OPTS=&quot;-Xms200m -Xmx200m&quot; 参数来限制最大使用 200m 堆内存, 但是不知道怎么回事, 内存还是会一直往上飙,</span>\n<span class=\"hljs-comment\"># 会远远超过我指定的内存</span>\n<span class=\"hljs-comment\"># 指定 NETWORK_HOST=&quot;0.0.0.0&quot;, 可以让 es 接受来自任意ip地址的访问</span>\n<span class=\"hljs-comment\"># 最后指定了本次启动的容器从 docker.io/elasticsearch:6.5.4 镜像创建</span>\ndocker run -d --name es -p 9200:9200 -p 9300:9300 -e ES_JAVA_OPTS=<span class=\"hljs-string\">&quot;-Xms150m -Xmx150m&quot;</span> -e NETWORK_HOST=<span class=\"hljs-string\">&quot;0.0.0.0&quot;</span> docker.io/elasticsearch:6.5.4</code></pre>\n\n<h3 id=\"安装-elasticsearch-head\"><a href=\"#安装-elasticsearch-head\" class=\"headerlink\" title=\"安装 elasticsearch-head\"></a>安装 elasticsearch-head</h3><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># elasticsearch-head 使用的端口是9100</span>\ndocker run -d -p 9100:9100 docker.io/mobz/elasticsearch-head:5</code></pre>\n\n<p>然后访问ip:9100, 在页面上填入 es 的地址ip:9200, 如果无法连接, 那么需要在 es 的配置文件 <code>elasticsearch.yml</code>中添加参数</p>\n<pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 如果启用了 HTTP 端口，那么此属性会指定是否允许跨源 REST 请求</span>\nhttp.cors.enabled: <span class=\"hljs-literal\">true</span>\n<span class=\"hljs-comment\"># 如果 http.cors.enabled 的值为 true，那么该属性会指定允许 REST 请求来自何处</span>\nhttp.cors.allow-origin: <span class=\"hljs-string\">&quot;*&quot;</span></code></pre>\n\n<h3 id=\"安装中文分词-ik\"><a href=\"#安装中文分词-ik\" class=\"headerlink\" title=\"安装中文分词 ik\"></a>安装中文分词 ik</h3><p>进入 es 容器中, 使用 es 自带的命令安装插件</p>\n<pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 注意安装对应 es 版本的 ik 分词插件, 我的 es 是6.5.4, 所以安装的6.5.4的 ik</span>\nelasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v6.5.4/elasticsearch-analysis-ik-6.5.4.zip</code></pre>\n\n<h3 id=\"elasticsearch-的使用\"><a href=\"#elasticsearch-的使用\" class=\"headerlink\" title=\"elasticsearch 的使用\"></a>elasticsearch 的使用</h3><p>参考<a href=\"https://imququ.com/post/elasticsearch.html\">使用 Elasticsearch 实现博客站内搜索</a></p>\n<p>初始化和写入数据都可以了, 但是现在碰到一个问题, 我的博客主站是托管在 github 上的, github 只提供静态资源服务, 那么我这个部署在阿里云上的 es 要如何联动起来使用上搜索功能呢?</p>\n<p><del>通过 nginx 分发?</del>目前使用 nginx 分发达到了在备用域名 try.kricsleo.com 上可以调用部署在阿里云上的 es 服务</p>\n<p>放出我的博客文章的 mapping </p>\n<pre><code class=\"hljs js\">&#123;\n  index: <span class=\"hljs-string\">&#x27;blog&#x27;</span>,\n  type: <span class=\"hljs-string\">&#x27;article&#x27;</span>,\n  body: &#123;\n    properties: &#123;\n      title: &#123;\n        type: <span class=\"hljs-string\">&#x27;text&#x27;</span>,\n        term_vector: <span class=\"hljs-string\">&#x27;with_positions_offsets&#x27;</span>,\n        analyzer: <span class=\"hljs-string\">&#x27;ik_max_word&#x27;</span>,\n        search_analyzer: <span class=\"hljs-string\">&#x27;ik_max_word&#x27;</span>\n      &#125;,\n      subtitle: &#123;\n        type: <span class=\"hljs-string\">&#x27;text&#x27;</span>,\n        term_vector: <span class=\"hljs-string\">&#x27;with_positions_offsets&#x27;</span>,\n        analyzer: <span class=\"hljs-string\">&#x27;ik_max_word&#x27;</span>,\n        search_analyzer: <span class=\"hljs-string\">&#x27;ik_max_word&#x27;</span>\n      &#125;,\n      content: &#123;\n        type: <span class=\"hljs-string\">&#x27;text&#x27;</span>,\n        term_vector: <span class=\"hljs-string\">&#x27;with_positions_offsets&#x27;</span>,\n        analyzer: <span class=\"hljs-string\">&#x27;ik_max_word&#x27;</span>,\n        search_analyzer: <span class=\"hljs-string\">&#x27;ik_max_word&#x27;</span>\n      &#125;,\n      link: &#123;\n        type: <span class=\"hljs-string\">&#x27;text&#x27;</span>\n      &#125;,\n      author: &#123;\n        type: <span class=\"hljs-string\">&#x27;text&#x27;</span>,\n      &#125;,\n      categories: &#123;\n        type: <span class=\"hljs-string\">&#x27;keyword&#x27;</span>,\n      &#125;,\n      tags: &#123;\n        type: <span class=\"hljs-string\">&#x27;keyword&#x27;</span>,\n      &#125;,\n      create_date: &#123;\n        type: <span class=\"hljs-string\">&#x27;date&#x27;</span>,\n        index: <span class=\"hljs-literal\">false</span>\n      &#125;,\n      update_date: &#123;\n        type: <span class=\"hljs-string\">&#x27;date&#x27;</span>,\n        index: <span class=\"hljs-literal\">false</span>\n      &#125;\n    &#125;\n  &#125;\n&#125;</code></pre>\n\n<p>搜索时使用的生成 DSL 查询语句的方法</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> generateDSL = <span class=\"hljs-function\">(<span class=\"hljs-params\">query = <span class=\"hljs-string\">&#x27;&#x27;</span>, <span class=\"hljs-keyword\">from</span> = <span class=\"hljs-number\">0</span>, size = <span class=\"hljs-number\">10</span></span>) =&gt;</span> (&#123;\n  index: <span class=\"hljs-string\">&#x27;blog&#x27;</span>,\n  type: <span class=\"hljs-string\">&#x27;article&#x27;</span>,\n  q: query,\n  <span class=\"hljs-keyword\">from</span>,\n  size,\n  body: &#123;\n    query: &#123;\n      dis_max: &#123;\n        queries: [\n          &#123;\n            match: &#123;\n              title: &#123;\n                query: keyword,\n                minimum_should_match: <span class=\"hljs-string\">&#x27;50%&#x27;</span>,\n                boost: <span class=\"hljs-number\">4</span>,\n              &#125;\n            &#125;\n          &#125;,\n          &#123;\n            match: &#123;\n              subtitle: &#123;\n                query: keyword,\n                minimum_should_match: <span class=\"hljs-string\">&#x27;50%&#x27;</span>,\n                boost: <span class=\"hljs-number\">4</span>,\n              &#125;\n            &#125;\n          &#125;, &#123;\n            match: &#123;\n              content: &#123;\n                query: keyword,\n                minimum_should_match: <span class=\"hljs-string\">&#x27;75%&#x27;</span>,\n                boost: <span class=\"hljs-number\">4</span>,\n              &#125;\n            &#125;\n          &#125;, &#123;\n            match: &#123;\n              tags: &#123;\n                query: keyword,\n                minimum_should_match: <span class=\"hljs-string\">&#x27;100%&#x27;</span>,\n                boost: <span class=\"hljs-number\">2</span>,\n              &#125;\n            &#125;\n          &#125;, &#123;\n            match: &#123;\n              categories: &#123;\n                query: keyword,\n                minimum_should_match: <span class=\"hljs-string\">&#x27;100%&#x27;</span>,\n                boost: <span class=\"hljs-number\">2</span>,\n              &#125;\n            &#125;\n          &#125;\n        ],\n        tie_breaker: <span class=\"hljs-number\">0.3</span>\n      &#125;\n    &#125;,\n    highlight: &#123;\n      pre_tags: [<span class=\"hljs-string\">&#x27;&lt;b&gt;&#x27;</span>],\n      post_tags: [<span class=\"hljs-string\">&#x27;&lt;/b&gt;&#x27;</span>],\n      fields: &#123;\n        title: &#123;&#125;,\n        content: &#123;&#125;,\n      &#125;\n    &#125;\n  &#125;\n&#125;);</code></pre>\n\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"https://imququ.com/post/elasticsearch.html\">使用 Elasticsearch 实现博客站内搜索</a><br><a href=\"http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html\">Docker 入门教程</a><br><a href=\"https://www.xuchuruo.cn/%E4%BD%BF%E7%94%A8docker%E5%AE%89%E8%A3%85elasticsearch.html\">docker安装elasticSearch以及系列插件</a><br><a href=\"https://blog.csdn.net/qq_23250633/article/details/81327001\">Docker安装elasticsearch5（爬坑心得）</a>: 内存不足无法启动 es 解决方法</p>","source":"_posts/docker.md","full_source":"/Users/krics/workspace/kricsleo_site/source/_posts/docker.md","path":"docker/","permalink":"https://kricsleo.com/docker/","photos":[],"link":""}